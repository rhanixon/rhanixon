{"ast":null,"code":"// /* eslint-disable react/jsx-no-target-blank */\n// import React, { Component } from \"react\";\n// import Sidebar from \"./Sidebar\";\n// export default class Writing extends Component {\n//   handleClick() {\n//     // window.open(\"/insert/your/path/here\");\n//     window.location.href = \"/fast\";\n//   }\n//   render() {\n//     return (\n//       <div>\n//         <Sidebar style={\"BurgerBlack.css\"} />\n//         <div className=\"writing-container\">\n//           <div className=\"bio-header\">\n//             <h1>Writing</h1>\n//           </div>\n//           <div className=\"boxed2\">\n//             <div className=\"bio-item\">\n//               <h2>I Wanna Go Fast</h2>\n//               <h3 className=\"oneandquarter\">\n//                 This spring, while my teammates and I were working on Hive Mind\n//                 - a real-time, multi-player, cross-platform mobile application\n//                 based on the New York Times Spelling Bee - we ran into an\n//                 interesting problem. Given a dictionary containing all the words\n//                 in the English language, generate all possible solutions for all\n//                 possible puzzles in our game. At first glance this problem may\n//                 seem trivial. But things start to get crazy when you factor in\n//                 the fact that there are 4,604,600 possible puzzles each of which\n//                 may contain as many as 1,000 valid words. Our first pass at\n//                 solving the problem iteratively would have taken over 6 hours to\n//                 run if we were willing to subject our computers to that kind of\n//                 torture. So the question quickly became: how can we possibly\n//                 make this faster? And after that, how fast can we possibly make\n//                 this thing?\n//               </h3>\n//               <a className=\"zero\" href=\"/Fast\">\n//                 <h3>\n//                   Check it out <i className=\"right\"></i>\n//                 </h3>\n//               </a>\n//             </div>\n//           </div>\n//         </div>\n//       </div>\n//     );\n//   }\n// }","map":{"version":3,"sources":["/Users/robertnixon/Desktop/PersonalWebsite/rhanixon.github.io/src/components/Writing.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// /* eslint-disable react/jsx-no-target-blank */\n// import React, { Component } from \"react\";\n// import Sidebar from \"./Sidebar\";\n// export default class Writing extends Component {\n//   handleClick() {\n//     // window.open(\"/insert/your/path/here\");\n//     window.location.href = \"/fast\";\n//   }\n//   render() {\n//     return (\n//       <div>\n//         <Sidebar style={\"BurgerBlack.css\"} />\n//         <div className=\"writing-container\">\n//           <div className=\"bio-header\">\n//             <h1>Writing</h1>\n//           </div>\n//           <div className=\"boxed2\">\n//             <div className=\"bio-item\">\n//               <h2>I Wanna Go Fast</h2>\n//               <h3 className=\"oneandquarter\">\n//                 This spring, while my teammates and I were working on Hive Mind\n//                 - a real-time, multi-player, cross-platform mobile application\n//                 based on the New York Times Spelling Bee - we ran into an\n//                 interesting problem. Given a dictionary containing all the words\n//                 in the English language, generate all possible solutions for all\n//                 possible puzzles in our game. At first glance this problem may\n//                 seem trivial. But things start to get crazy when you factor in\n//                 the fact that there are 4,604,600 possible puzzles each of which\n//                 may contain as many as 1,000 valid words. Our first pass at\n//                 solving the problem iteratively would have taken over 6 hours to\n//                 run if we were willing to subject our computers to that kind of\n//                 torture. So the question quickly became: how can we possibly\n//                 make this faster? And after that, how fast can we possibly make\n//                 this thing?\n//               </h3>\n//               <a className=\"zero\" href=\"/Fast\">\n//                 <h3>\n//                   Check it out <i className=\"right\"></i>\n//                 </h3>\n//               </a>\n//             </div>\n//           </div>\n//         </div>\n//       </div>\n//     );\n//   }\n// }\n"]},"metadata":{},"sourceType":"module"}